
责任链模式(Chain of Responsibility Pattern):

备注：
    责任链与策略模式有很多相似之处，如都是行为型设计模式，都能够处理代码中的if-else逻辑
    主要区别在于:
    
    责任链  封装了算法，通过上下文对象去接受客户端的数据，根据数据类型执行不同的算法
    
    策略模式的客户端知道所有算法以及各种算法的区别


    	
          使多个处理器都有机会处理请求， 从而避免请求的发送者和接受者之间的耦合关系， 
          将这些处理器连成一条链， 并沿着这条链传递该请求，直到有一个处理器处理他为止。
    
	为请求创建了一个接收者(处理器)对象的链。
	在这种模式中，通常每个接收者都包含对另一个接收者的引用，
	如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

纯的与不纯的责任链模式
一个纯的责任链模式要求一个具体的处理者只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。
不允许出现某一个具体处理者在承担了一部分责任后又 把责任向下传的情况。

在一个       纯的   责任链模式里面，一个请求必须被某一个处理者所接收；
在一个  不纯的   责任链模式里面，一个请求可以最终不被任何接收端对象所接收。


纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。

  a.外部控制模式
  	链的每个节点只需要专注于各自的逻辑即可，而当前节点调用完成之后,返回true 或 false,
  	是否继续调用下一个节点，这个则由外部控制逻辑进行。
  	
  	这种责任链设计方式的优点在于链的控制比较简单，只需要实现一个统一的接口即可，其基本上能够满足大部分的逻辑控制，
  	
  	但是对于某些需要动态调整链的需求其就无能为力了。
  	比如在执行到某个节点之后需要动态的判断是否执行下一个节点，
  	或者说要执行某些分叉的节点等等,这个时候我们就需要将链节点的传递工作交由各个节点进行。
  	
  	比如申请信用卡的时候，需要校验 申请人的 稳定合法收入、是否有稳定住所、是否有不良行为记录等等，
  
    for(Filter f : filters){
			boolean res = f.filter(null);	
			System.out.println(res);
			/**是否中断， 在 每个处理器节点的    外部的此处的控制**/
			/*
			 * 有一个校验不通过的话， 执行其他的业务逻辑
			 * if(!res){
				break;
				
			}*/
		}
		/**校验通过的话， 执行其他的业务逻辑
		 * 
		 * donext。。。。
		 */
  	见   outer 下的代码.
  	
  b.节点控制模式
     假如规定学生请假小于或等于 2 天，班主任可以批准；
                                             小于或等于 7 天，系主任可以批准；
                                             小于或等于 10 天，院长可以批准；
                                             其他情况不予批准；
        这个实例适合使用职责链模式实现
  
    
  